<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drawing AI Assistant</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 0; 
      padding: 0; 
      background: #f9f9f9; 
    }
    header { 
      background: #4a90e2; 
      color: white; 
      padding: 1em; 
      text-align: center; 
      font-size: 1.5em; 
    }
    main { 
      display: flex; 
      min-height: calc(100vh - 80px);
      flex-direction: row;
    }
    aside { 
      width: 200px; 
      background: #fff; 
      padding: 1em; 
      border-right: 1px solid #ccc; 
      overflow-y: auto;
    }
    #workspace { 
      flex: 1; 
      padding: 1em; 
      display: flex; 
      flex-direction: column; 
      min-width: 0;
    }
    #ai-response { 
      background: #e8f0fe; 
      padding: 1em; 
      margin-bottom: 1em; 
      border-radius: 6px; 
      min-height: 60px;
      animation: fadeIn 0.5s ease-out;
    }
    #result-area { 
      flex: 1; 
      background: #fff; 
      border: 1px dashed #aaa; 
      padding: 1em; 
      position: relative; 
      display: flex;
      justify-content: center;
      align-items: center;
    }
    button, select { 
      margin: 0.3em 0; 
      padding: 0.5em; 
      cursor: pointer; 
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f8f9fa;
      width: 100%;
      font-size: 14px;
    }
    button:hover {
      background: #e9ecef;
    }
    .active-tool { 
      background: #4a90e2 !important; 
      color: white !important; 
    }
    #canvas { 
      border: 1px solid #ccc; 
      display: block; 
      cursor: crosshair;
      max-width: 100%;
      max-height: 100%;
      position: relative;
      z-index: 2;
    }

    .reference-controls {
      display: flex;
      gap: 0.5em;
      margin-bottom: 1em;
      align-items: center;
    }

    #imageUrl {
      flex: 1;
      padding: 0.5em;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }

    #reference-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    #referenceImage {
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0.7;
      border: 1px solid #ddd;
    }

    .reference-controls-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 5px;
      border-radius: 5px;
      display: flex;
      gap: 5px;
      align-items: center;
      pointer-events: all;
      font-size: 12px;
    }

    .reference-controls-overlay button {
      padding: 3px 8px;
      font-size: 12px;
      margin: 0;
      width: auto;
    }

    .reference-controls-overlay input[type="range"] {
      width: 60px;
      margin: 0;
    }

    #opacityLabel {
      font-size: 11px;
      color: #666;
    }
    .tool-section { 
      margin-bottom: 1.5em; 
      border-bottom: 1px solid #eee;
      padding-bottom: 1em;
    }
    .tool-section:last-child {
      border-bottom: none;
    }
    .tool-section h4 { 
      margin: 0 0 0.5em 0; 
      color: #333;
      font-size: 16px;
    }
    #colorPicker { 
      width: 100%; 
      height: 40px; 
      border: 1px solid #ccc; 
      cursor: pointer; 
      margin-bottom: 0.5em;
    }
    #brushSize { 
      width: 100%; 
      margin-bottom: 0.5em;
    }
    .color-preset {
      display: inline-block;
      width: 30px;
      height: 30px;
      margin: 2px;
      border: 1px solid #ccc;
      cursor: pointer;
      border-radius: 3px;
    }
    .ai-controls {
      display: flex;
      gap: 0.5em;
      margin-bottom: 1em;
    }
    #prompt {
      flex: 1;
      padding: 0.5em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #333;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    .layer-item {
      display: flex;
      align-items: center;
      padding: 0.3em;
      border: 1px solid #ddd;
      margin-bottom: 0.2em;
      border-radius: 3px;
      background: #f9f9f9;
    }

    .layer-item.active {
      background: #e3f2fd;
      border-color: #4a90e2;
    }

    .layer-item input[type="text"] {
      flex: 1;
      border: none;
      background: transparent;
      font-size: 12px;
      margin-left: 0.3em;
    }

    .layer-controls {
      display: flex;
      gap: 0.2em;
      margin-left: 0.3em;
    }

    .layer-controls button {
      padding: 0.2em 0.4em;
      font-size: 10px;
      margin: 0;
      width: auto;
    }

    .keyboard-shortcuts {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 11px;
      max-width: 200px;
      display: none;
    }

    .shortcuts-toggle {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: #4a90e2;
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      font-size: 16px;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      main {
        flex-direction: column;
      }
      aside {
        width: 100%;
        padding: 0.5em;
      }
      .tool-section {
        margin-bottom: 1em;
      }
      #workspace {
        padding: 0.5em;
      }
      header {
        font-size: 1.2em;
        padding: 0.5em;
      }
      #canvas {
        width: 100%;
        height: 300px;
      }
    }

    @media (max-width: 480px) {
      .ai-controls, .reference-controls {
        flex-direction: column;
      }
      button {
        padding: 0.7em;
        font-size: 16px;
      }
      .reference-controls-overlay {
        flex-direction: column;
        gap: 3px;
      }
      .reference-controls-overlay input[type="range"] {
        width: 80px;
      }
    }

      @keyframes glow {
        from { box-shadow: 0 0 5px #f5576c; }
        to { box-shadow: 0 0 20px #f5576c, 0 0 30px #f5576c; }
      }

      @keyframes fadeIn {
        from { 
          opacity: 0; 
          transform: translateY(10px); 
        }
        to { 
          opacity: 1; 
          transform: translateY(0); 
        }
      }

      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }

    .voice-recording {
      animation: pulse 1s ease-in-out infinite;
      background: #e74c3c !important;
      box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
    }

    .auto-speak-on {
      background: #27ae60 !important;
      box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
    }

    .voice-status {
      position: fixed;
      top: 100px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 15px;
      border-radius: 20px;
      font-size: 14px;
      z-index: 1000;
      display: none;
      animation: fadeIn 0.3s ease-in;
    }

    /* Advanced Features Styling */
    .symmetry-line {
      position: absolute;
      background: rgba(255, 0, 0, 0.3);
      pointer-events: none;
      z-index: 3;
    }

    .perspective-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .gallery-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 10000;
      overflow-y: auto;
    }

    .gallery-content {
      background: white;
      margin: 2% auto;
      padding: 20px;
      width: 90%;
      max-width: 1000px;
      border-radius: 10px;
      position: relative;
    }

    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .gallery-item {
      border: 2px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .gallery-item:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .gallery-item img {
      width: 100%;
      height: 150px;
      object-fit: cover;
    }

    .gallery-item-info {
      padding: 10px;
      font-size: 12px;
      background: #f9f9f9;
    }

    .close-gallery {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      cursor: pointer;
      color: #999;
    }

    .close-gallery:hover {
      color: #333;
    }

    .pattern-brush {
      background: linear-gradient(45deg, #ff6b6b, #feca57) !important;
      color: white !important;
    }

    .gradient-tool {
      background: linear-gradient(45deg, #667eea, #764ba2) !important;
      color: white !important;
    }

    .symmetry-active {
      background: #e74c3c !important;
      color: white !important;
      box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
    }

    .grid-active {
      background: #3498db !important;
      color: white !important;
      box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
    }
  
.zoom-controls .zoom-btn {
  flex:1;
  padding: 0.5em;
  cursor: pointer;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #f8f9fa;
  font-size: 14px;
}
.zoom-controls .zoom-btn:hover {
  background: #e9ecef;
}

</style>
</head>
<body>
  <header>Drawing AI Assistant</header>
  <main>
    <aside>
      <h3>Drawing Tools</h3>
      <div class="tool-section">
        <h4>Basic Tools</h4>
        <div class="tooltip">
          <button id="pencil" onclick="setTool('pencil')" class="active-tool">‚úèÔ∏è Pencil</button>
          <span class="tooltiptext">Draw freehand with your mouse or finger</span>
        </div>
        <div class="tooltip">
          <button id="eraser" onclick="setTool('eraser')">üßπ Eraser</button>
          <span class="tooltiptext">Erase parts of your drawing</span>
        </div>
        <div class="tooltip">
          <button id="fill" onclick="setTool('fill')">ü™£ Fill</button>
          <span class="tooltiptext">Fill enclosed areas with color</span>
        </div>
        <div class="tooltip">
          <button id="eyedropper" onclick="setTool('eyedropper')">üíß Eyedropper</button>


<div class="tooltip">
  <div class="zoom-controls" style="display:flex; gap:4px; align-items:center; margin-top:6px; width:100%;">
    <button onclick="zoomOut()" class="zoom-btn">‚ûñ Zoom</button>
    <button onclick="zoomIn()" class="zoom-btn">‚ûï Zoom</button>
    <span id="zoomLevel" style="min-width:45px; text-align:center;">100%</span>
  </div>
  <span class="tooltiptext">Use zoom controls to magnify canvas. Hold Shift + Drag to pan.</span>
</div>



          <span class="tooltiptext">Pick color from canvas</span>
        </div>
      </div>
      <div class="tool-section">
        <h4>History</h4>
        <button onclick="undo()" id="undoBtn">‚Ü∂ Undo</button>
        <button onclick="redo()" id="redoBtn">‚Ü∑ Redo</button>
      </div>
        <div class="tooltip">
          <button id="tool-crop" onclick="mc_openCropper()">‚úÇÔ∏è Crop</button>
          <span class="tooltiptext">Crop the current drawing (enter crop mode)</span>
        </div>

      <div class="tool-section">
        <h4>Layers</h4>
        <div id="layersList"></div>
        <button onclick="addLayer()" style="font-size: 12px;">+ Add Layer</button>
      </div>
      <div class="tool-section">
        <h4>Brush Settings</h4>
        <label for="brushSize">Size: <span id="sizeDisplay">5px</span></label>
        <input type="range" id="brushSize" min="1" max="50" value="5" onchange="setBrushSize(this.value)">
      </div>
      <div class="tool-section">
        <h4>Enhanced Color System</h4>
        
        <!-- Main Color Picker -->
        <div style="display: flex; gap: 0.5em; align-items: center; margin-bottom: 0.5em;">
          <input type="color" id="colorPicker" value="#000000" onchange="setColor(this.value)">
          <div style="display: flex; gap: 0.3em;">
            <div id="primaryColor" style="width: 30px; height: 30px; background-color: #000000; border: 3px solid #4a90e2; border-radius: 4px; cursor: pointer;" onclick="selectPrimaryColor()" title="Primary Color"></div>
            <div id="secondaryColor" style="width: 30px; height: 30px; background-color: #ffffff; border: 2px solid #ccc; border-radius: 4px; cursor: pointer;" onclick="selectSecondaryColor()" title="Secondary Color"></div>
          </div>
        </div>

        <!-- HSV Controls -->
        <div style="margin-bottom: 0.8em;">
          <div style="display: flex; align-items: center; gap: 0.5em; margin-bottom: 0.3em; font-size: 12px;">
            <label style="min-width: 30px; font-weight: bold;">H:</label>
            <input type="range" id="hueSlider" min="0" max="360" value="0" oninput="updateFromHSV()" style="flex: 1; margin: 0;">
            <span id="hueValue" style="min-width: 30px; text-align: right; font-size: 11px;">0¬∞</span>
          </div>
          <div style="display: flex; align-items: center; gap: 0.5em; margin-bottom: 0.3em; font-size: 12px;">
            <label style="min-width: 30px; font-weight: bold;">S:</label>
            <input type="range" id="satSlider" min="0" max="100" value="0" oninput="updateFromHSV()" style="flex: 1; margin: 0;">
            <span id="satValue" style="min-width: 30px; text-align: right; font-size: 11px;">0%</span>
          </div>
          <div style="display: flex; align-items: center; gap: 0.5em; margin-bottom: 0.3em; font-size: 12px;">
            <label style="min-width: 30px; font-weight: bold;">L:</label>
            <input type="range" id="lightSlider" min="0" max="100" value="0" oninput="updateFromHSV()" style="flex: 1; margin: 0;">
            <span id="lightValue" style="min-width: 30px; text-align: right; font-size: 11px;">0%</span>
          </div>
        </div>

        <!-- Color Mixer -->
        <div style="border: 1px solid #ddd; border-radius: 4px; padding: 0.5em; margin-bottom: 0.8em; background: #f9f9f9;">
          <h6 style="margin: 0 0 0.5em 0; font-size: 12px; font-weight: bold;">üé® Color Mixer</h6>
          <div style="display: flex; align-items: center; gap: 0.3em; margin-bottom: 0.5em;">
            <div id="mixColor1" style="width: 30px; height: 30px; background-color: #ff0000; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;" onclick="setMixColor(1)" title="Mix Color 1"></div>
            <span>+</span>
            <div id="mixColor2" style="width: 30px; height: 30px; background-color: #0000ff; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;" onclick="setMixColor(2)" title="Mix Color 2"></div>
            <span>=</span>
            <div id="mixResult" style="width: 40px; height: 30px; background-color: #800080; border: 2px solid #4a90e2; border-radius: 3px; cursor: pointer;" onclick="useMixedColor()" title="Use Mixed Color"></div>
          </div>
          <div style="display: flex; align-items: center; gap: 0.3em; font-size: 11px;">
            <span>Blend:</span>
            <input type="range" id="mixRatio" min="0" max="100" value="50" oninput="updateMixture()" style="flex: 1; margin: 0;">
            <span id="mixValue">50%</span>
          </div>
        </div>

        <!-- Color History -->
        <div style="margin-bottom: 0.8em;">
          <h6 style="margin: 0 0 0.3em 0; font-size: 12px; font-weight: bold;">üìö Recent Colors</h6>
          <div id="colorHistory" style="display: flex; flex-wrap: wrap; gap: 0.2em;"></div>
        </div>

        <!-- Palette Tabs -->
        <div style="display: flex; margin-bottom: 0.5em;">
          <div class="palette-tab active" onclick="switchPalette('basic')" style="flex: 1; padding: 0.3em; font-size: 10px; background: #4a90e2; color: white; border: 1px solid #357abd; cursor: pointer; text-align: center; border-radius: 3px 0 0 3px;">Basic</div>
          <div class="palette-tab" onclick="switchPalette('skin')" style="flex: 1; padding: 0.3em; font-size: 10px; background: #f0f0f0; border: 1px solid #ddd; cursor: pointer; text-align: center;">Skin</div>
          <div class="palette-tab" onclick="switchPalette('nature')" style="flex: 1; padding: 0.3em; font-size: 10px; background: #f0f0f0; border: 1px solid #ddd; cursor: pointer; text-align: center;">Nature</div>
          <div class="palette-tab" onclick="switchPalette('cool')" style="flex: 1; padding: 0.3em; font-size: 10px; background: #f0f0f0; border: 1px solid #ddd; cursor: pointer; text-align: center; border-radius: 0 3px 3px 0;">Cool</div>
        </div>

        <!-- Extended Color Palettes -->
        <div id="colorPalette" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.2em;"></div>
      </div>
    </aside>

    <div id="workspace">
      <div id="ai-response">
        <strong>ü§ñ AI Drawing Assistant</strong><br>
        Ask me: "draw a cat" or "help with tools"<br><br>
        <strong>Examples:</strong><br>
        ‚Ä¢ "cat" - drawing steps<br>
        ‚Ä¢ "house" - shape guide<br>
        ‚Ä¢ "pencil not working" - quick fix - Tool-specific guidance
      </div>
      <div class="ai-controls">
        <input type="text" id="prompt" placeholder="What would you like to draw or need help with? (e.g., cat, house, tree, 'help with tools', 'brush not working')">
        <button onclick="askAI()">ü§ñ Ask AI</button>
        <button onclick="askAI('premium')" id="premium-ask-btn" style="background: linear-gradient(45deg, #ff6b6b, #ee5a24); color: white;">‚ú® Premium AI</button>
        <button onclick="toggleVoiceInput()" id="voice-btn" style="background: #e74c3c; color: white; min-width: 80px;">üé§ Voice</button>
        <button onclick="toggleAutoSpeak()" id="speak-btn" style="background: #9b59b6; color: white; min-width: 80px;">üîä Speak</button>
      </div></script>
    </script>
    <style>
      #premium-ask-btn {
        margin-left: 0.5em;
        min-width: 120px;
        font-weight: bold;
      }

      #premium-ask-btn:disabled {
        background: #ccc !important;
        cursor: not-allowed;
      }
    
.zoom-controls .zoom-btn {
  flex:1;
  padding: 0.5em;
  cursor: pointer;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #f8f9fa;
  font-size: 14px;
}
.zoom-controls .zoom-btn:hover {
  background: #e9ecef;
}

</style>
      <div class="reference-controls">
        <input type="url" id="imageUrl" placeholder="Try: https://images.unsplash.com/photo-1574158622682-e40e69881006 (cat) or https://i.imgur.com/example.jpg">
        <button onclick="loadReference()">üì∑ Load Reference</button>
        <button onclick="clearReference()" id="clearRefBtn" style="display: none;">‚ùå Clear Reference</button>
        <button onclick="showImageExamples()" style="font-size: 12px;">üí° Examples</button>
      </div>
      <div id="result-area">
        <div id="reference-container" style="display: none;">
          <img id="referenceImage" alt="Reference image" />
          <div class="reference-controls-overlay">
            <button onclick="toggleReference()" id="toggleRefBtn">üëÅÔ∏è Hide</button>
            <input type="range" id="opacitySlider" min="0.1" max="1" step="0.1" value="0.7" onchange="setReferenceOpacity(this.value)">
            <span id="opacityLabel">70%</span>
          </div>
        </div>
        <canvas id="canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <aside>
      <h3>Advanced Tools</h3>
      <div class="tool-section">
        <h4>Drawing Features</h4>
        <div class="tooltip">
          <button id="gradient" onclick="setTool('gradient')" class="gradient-tool">üåà Gradient</button>
          <span class="tooltiptext">Create smooth color transitions</span>
        </div>
        <div class="tooltip">
          <button id="pattern" onclick="setTool('pattern')" class="pattern-brush">üî∂ Pattern</button>
          <span class="tooltiptext">Textured brush patterns</span>
        </div>
        <div class="tooltip">
          <button id="symmetry" onclick="toggleSymmetry()">ü™û Symmetry</button>
          <span class="tooltiptext">Mirror drawing mode</span>
        </div>
        <div class="tooltip">
          <button id="grid" onclick="toggleGrid()">üìê Grid</button>
          <span class="tooltiptext">Perspective drawing grid</span>
        </div>
      </div>
      <div class="tool-section">
        <h4>Shapes</h4>
        <div class="tooltip">
          <button id="rectangle" onclick="setTool('rectangle')">‚¨ú Rectangle</button>
          <span class="tooltiptext">Click and drag to draw a rectangle</span>
        </div>
        <div class="tooltip">
          <button id="circle" onclick="setTool('circle')">‚≠ï Circle</button>
          <span class="tooltiptext">Click and drag to draw a circle</span>
        </div>
        <div class="tooltip">
          <button id="line" onclick="setTool('line')">üìè Line</button>
          <span class="tooltiptext">Click and drag to draw a straight line</span>
        </div>
        <div class="tooltip">
          <button id="triangle" onclick="setTool('triangle')">üî∫ Triangle</button>
          <span class="tooltiptext">Click and drag to draw a triangle</span>
        </div>
        <div class="tooltip">
          <button id="star" onclick="setTool('star')">‚≠ê Star</button>
          <span class="tooltiptext">Click and drag to draw a star</span>
        </div>
        <div class="tooltip">
          <button id="arrow" onclick="setTool('arrow')">‚û§ Arrow</button>
          <span class="tooltiptext">Click and drag to draw an arrow</span>
        </div>
      </div>
      <div class="tool-section">
        <h4>Shape Options</h4>
        <label>
          <input type="checkbox" id="fillShapes" onchange="toggleFillShapes()"> Fill shapes
        </label>
        <div style="margin-top: 0.5em;">
          <label for="shapeOpacity">Opacity: <span id="opacityDisplay">100%</span></label>
          <input type="range" id="shapeOpacity" min="0.1" max="1" step="0.1" value="1" onchange="setShapeOpacity(this.value)" style="width: 100%;">
        </div>
      </div>
      <div class="tool-section">
        <h4>AI Features</h4>
        <div class="tooltip">
          <button onclick="analyzeDrawing()">ü§ñ Analyze Art</button>
          <span class="tooltiptext">Get AI feedback on composition</span>
        </div>
        <div class="tooltip">
          <button onclick="suggestColors()">üé® Color Palette</button>
          <span class="tooltiptext">AI color suggestions</span>
        </div>
        <div class="tooltip">
          <button onclick="openGallery()">üñºÔ∏è Gallery</button>
          <span class="tooltiptext">View saved drawings</span>
        </div>
      </div>
      <div class="tool-section">
        <h4>Canvas Actions</h4>
        <div class="tooltip">
          <button onclick="clearCanvas()">üóëÔ∏è Clear Canvas</button>
          <span class="tooltiptext">Clear everything on the canvas</span>
        </div>
        <div class="tooltip">
          <button onclick="saveCanvas()">üíæ Save Drawing</button>
          <span class="tooltiptext">Download your drawing as a PNG image</span>
        </div>
        <div class="tooltip">
          <button onclick="exportSVG()" style="font-size: 12px;">üìÑ Export SVG</button>
          <span class="tooltiptext">Export as scalable vector graphics</span>
        </div>
        <div class="tooltip">
          <button onclick="exportPDF()" style="font-size: 12px;">üìë Export PDF</button>
          <span class="tooltiptext">Export as PDF document</span>
        </div>
        <div class="tooltip">
          <button onclick="loadImageFile()" style="font-size: 12px;">üìÅ Load Image</button>
          <span class="tooltiptext">Load image from your device</span>
        </div>
        <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="handleFileLoad(event)">
      </div>
    </aside>
  </main>

  <div class="voice-status" id="voiceStatus">üé§ Listening...</div>

  <button class="shortcuts-toggle" onclick="toggleShortcuts()">‚å®Ô∏è</button>
  <div class="keyboard-shortcuts" id="keyboardShortcuts">
    <strong>Keyboard Shortcuts:</strong><br>
    Ctrl+Z - Undo<br>
    Ctrl+Y - Redo<br>
    Ctrl+S - Save<br>
    P - Pencil<br>
    E - Eraser<br>
    F - Fill<br>
    R - Rectangle<br>
    C - Circle<br>
    L - Line<br>
    T - Triangle<br>
    [ ] - Brush size<br>
    1-5 - Color presets<br>
    V - Voice Input<br>
    M - Toggle Auto-Speak
  </div>

  <div class="gallery-modal" id="galleryModal">
    <div class="gallery-content">
      <span class="close-gallery" onclick="closeGallery()">&times;</span>
      <h2>Your Gallery</h2>
      <div class="gallery-grid" id="galleryGrid">
        <!-- Gallery items will be dynamically added here -->
      </div>
    </div>
  </div>

  <script src="/static/premium_features.js"></script>
  <script>
    // Canvas setup with performance optimizations
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    
// HiDPI crisp lines: scale canvas internal resolution to devicePixelRatio (no ctx scaling)
(function(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  function sizeCanvasForDPR(){
    const rect = canvas.getBoundingClientRect();
    const targetW = Math.max(1, Math.round(rect.width  * dpr));
    const targetH = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== targetW || canvas.height !== targetH) {
      // preserve current pixels
      const tmp = document.createElement('canvas');
      tmp.width = canvas.width; tmp.height = canvas.height;
      tmp.getContext('2d').drawImage(canvas, 0, 0);
      canvas.width = targetW; canvas.height = targetH;
      // redraw preserved content scaled to new pixel size
      const c = canvas.getContext('2d');
      c.imageSmoothingEnabled = true;
      c.drawImage(tmp, 0, 0, tmp.width, tmp.height, 0, 0, targetW, targetH);
    }
    // IMPORTANT: do NOT scale the context; getMousePos already maps to canvas pixels
  }
  window.addEventListener('resize', sizeCanvasForDPR);
  window.requestAnimationFrame(sizeCanvasForDPR);
})();
// Performance optimizations
    ctx.imageSmoothingEnabled = false; // Faster rendering
    let isDrawing = false;
    let drawingTimeout = null;

    // Voice Assistant Setup
    let recognition = null;
    let synthesis = window.speechSynthesis;
    let isListening = false;
    let autoSpeak = false;
    let voices = [];

    // Initialize Speech Recognition
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = function() {
        isListening = true;
        document.getElementById('voice-btn').classList.add('voice-recording');
        showVoiceStatus('üé§ Listening for your drawing request...');
      };

      recognition.onresult = function(event) {
        const transcript = event.results[0][0].transcript;
        document.getElementById('prompt').value = transcript;
        showVoiceStatus(`‚úÖ Heard: "${transcript}"`);

        // Auto-ask AI after voice input
        setTimeout(() => {
          askAI();
          hideVoiceStatus();
        }, 1000);
      };

      recognition.onerror = function(event) {
        console.error('Speech recognition error:', event.error);
        showVoiceStatus(`‚ùå Error: ${event.error}`);
        setTimeout(hideVoiceStatus, 3000);
        stopListening();
      };

      recognition.onend = function() {
        stopListening();
      };
    }

    // Load available voices
    function loadVoices() {
      voices = synthesis.getVoices();
      // Prefer female voices for AI assistant
      const preferredVoices = voices.filter(voice => 
        voice.name.toLowerCase().includes('female') || 
        voice.name.toLowerCase().includes('samantha') ||
        voice.name.toLowerCase().includes('karen') ||
        voice.name.toLowerCase().includes('zira')
      );
      if (preferredVoices.length > 0) {
        voices = preferredVoices;
      }
    }

    if (synthesis.onvoiceschanged !== undefined) {
      synthesis.onvoiceschanged = loadVoices;
    }
    loadVoices();

    // Drawing state
    let currentTool = 'pencil';
    let currentColor = '#000000';
    let brushSize = 5;
    let startX, startY;

    // Touch support variables
    let lastTouchX = 0;
    let lastTouchY = 0;

    // Undo/Redo system
    let undoStack = [];
    let redoStack = [];
    let maxUndoSteps = 50;

    // Layers system
    let layers = [{ id: 'layer1', name: 'Layer 1', visible: true, opacity: 1 }];
    let currentLayerId = 'layer1';
    let layerCanvases = {};

    // Fill tool variables
    let fillTolerance = 10;

    // Mouse events
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);

    // Touch events for mobile
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    function getTouchPos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.touches[0].clientX - rect.left) * scaleX,
        y: (e.touches[0].clientY - rect.top) * scaleY
      };
    }

    function handleTouchStart(e) {
      e.preventDefault();
      const touch = getTouchPos(e);
      lastTouchX = touch.x;
      lastTouchY = touch.y;

      const mouseEvent = new MouseEvent('mousedown', {
        clientX: e.touches[0].clientX,
        clientY: e.touches[0].clientY
      });
      canvas.dispatchEvent(mouseEvent);
    }

    function handleTouchMove(e) {
      e.preventDefault();
      const mouseEvent = new MouseEvent('mousemove', {
        clientX: e.touches[0].clientX,
        clientY: e.touches[0].clientY
      });
      canvas.dispatchEvent(mouseEvent);
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      const mouseEvent = new MouseEvent('mouseup', {});
      canvas.dispatchEvent(mouseEvent);
    }

    function startDrawing(e) {
      const pos = getMousePos(e);
      startX = pos.x;
      startY = pos.y;

      if (currentTool === 'fill') {
        floodFill(Math.floor(startX), Math.floor(startY), currentColor);
        saveState();
        return;
      }

      if (currentTool === 'eyedropper') {
        pickColor(Math.floor(startX), Math.floor(startY));
        return;
      }

      isDrawing = true;

      if (currentTool === 'pencil' || currentTool === 'eraser') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
      }
    }

    // Performance optimization variables
    let lastDrawTime = 0;
    let drawBuffer = [];
    const DRAW_INTERVAL = 16; // ~60fps

    function draw(e) {
      if (!isDrawing) return;

      const now = performance.now();
      if (now - lastDrawTime < DRAW_INTERVAL) {
        // Buffer the drawing event for smooth performance
        drawBuffer.push(e);
        return;
      }

      lastDrawTime = now;

      // Process buffered events
      if (drawBuffer.length > 0) {
        drawBuffer.forEach(bufferedEvent => processDrawEvent(bufferedEvent));
        drawBuffer = [];
      }

      processDrawEvent(e);
    }

    function processDrawEvent(e) {
      const pos = getMousePos(e);

      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      if (currentTool === 'pencil') {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = currentColor;
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();

        // Mirror drawing if symmetry is enabled
        if (symmetryEnabled) {
          const mirrorX = symmetryLine * 2 - pos.x;
          ctx.lineTo(mirrorX, pos.y);
          ctx.stroke();
        }
      } else if (currentTool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();

        if (symmetryEnabled) {
          const mirrorX = symmetryLine * 2 - pos.x;
          ctx.lineTo(mirrorX, pos.y);
          ctx.stroke();
        }
      } else if (currentTool === 'pattern') {
        drawPattern(pos.x, pos.y);

        if (symmetryEnabled) {
          const mirrorX = symmetryLine * 2 - pos.x;
          drawPattern(mirrorX, pos.y);
        }
      }
    }

    // Add event listener for when pencil/eraser strokes end
    canvas.addEventListener('mouseup', function(e) {
      if (isDrawing && (currentTool === 'pencil' || currentTool === 'eraser')) {
        setTimeout(() => saveState(), 10);
      }
    });

    function stopDrawing(e) {
      if (!isDrawing) return;

      const pos = getMousePos(e);

      if (currentTool === 'rectangle') {
        drawRectangle(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawRectangle(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'circle') {
        drawCircle(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawCircle(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'line') {
        drawLine(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawLine(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'triangle') {
        drawTriangle(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawTriangle(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'star') {
        drawStar(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawStar(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'arrow') {
        drawArrow(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawArrow(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'gradient') {
        drawGradient(startX, startY, pos.x, pos.y);
        saveState();
      }

      isDrawing = false;
      ctx.beginPath();
    }

    function drawRectangle(x1, y1, x2, y2) {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.fillStyle = currentColor;
      ctx.lineWidth = brushSize;
      ctx.globalAlpha = document.getElementById('shapeOpacity').value;

      if (document.getElementById('fillShapes').checked) {
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }
      ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
      ctx.globalAlpha = 1;
    }

    function drawCircle(x1, y1, x2, y2) {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.fillStyle = currentColor;
      ctx.lineWidth = brushSize;
      ctx.globalAlpha = document.getElementById('shapeOpacity').value;

      const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      ctx.beginPath();
      ctx.arc(x1, y1, radius, 0, 2 * Math.PI);

      if (document.getElementById('fillShapes').checked) {
        ctx.fill();
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function drawLine(x1, y1, x2, y2) {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.lineWidth = brushSize;
      ctx.globalAlpha = document.getElementById('shapeOpacity').value;

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function drawTriangle(x1, y1, x2, y2) {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.fillStyle = currentColor;
      ctx.lineWidth = brushSize;
      ctx.globalAlpha = document.getElementById('shapeOpacity').value;

      const width = x2 - x1;
      const height = y2 - y1;

      ctx.beginPath();
      ctx.moveTo(x1 + width / 2, y1); // Top point
      ctx.lineTo(x1, y2); // Bottom left
      ctx.lineTo(x2, y2); // Bottom right
      ctx.closePath();

      if (document.getElementById('fillShapes').checked) {
        ctx.fill();
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function setTool(tool) {
      currentTool = tool;

      // Remove active class from all tool buttons
      document.querySelectorAll('button').forEach(btn => btn.classList.remove('active-tool'));

      // Add active class to selected tool
      const toolButton = document.getElementById(tool);
      if (toolButton) {
        toolButton.classList.add('active-tool');
      }

      // Set cursor style based on tool
      canvas.style.cursor = currentTool === 'eraser' ? 'crosshair' : 'crosshair';
    }

    function setColor(color) {
      currentColor = color;
      document.getElementById('colorPicker').value = color;
      updatePrimaryColorDisplay();
      addToColorHistory(color);
      updateHSVFromColor(color);
    }

    function setBrushSize(size) {
      brushSize = size;
      document.getElementById('sizeDisplay').textContent = size + 'px';
    }

    // ===== Enhanced Color System Functions =====
    let colorHistory = [];
    let mixColor1 = '#ff0000';
    let mixColor2 = '#0000ff';
    let currentPalette = 'basic';

    // Color Palettes
    const colorPalettes = {
      basic: ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#808080', '#800000', '#008000', '#000080', '#800080', '#008080', '#808000', '#c0c0c0', '#ff8000', '#8000ff'],
      skin: ['#fdbcb4', '#eaa885', '#e1975e', '#cd8455', '#c67856', '#ad6b47', '#8d5524', '#6a4319', '#574428', '#3c281e', '#f2d2bd', '#e8b896', '#d4956c', '#c17d47', '#b5703c', '#a0522d', '#8b4513', '#654321'],
      nature: ['#90ee90', '#228b22', '#006400', '#8fbc8f', '#2e8b57', '#98fb98', '#00ff7f', '#00fa9a', '#3cb371', '#20b2aa', '#87ceeb', '#4682b4', '#b0c4de', '#778899', '#708090', '#2f4f4f', '#696969', '#a0522d'],
      cool: ['#e6f3ff', '#cce7ff', '#99d6ff', '#66c2ff', '#33adff', '#0099ff', '#0080cc', '#006699', '#004d66', '#003333', '#f0f8ff', '#e0e6fa', '#c6d9f0', '#9fc3e6', '#7ba5dc', '#5b8bd1', '#3f72c6', '#2559bb']
    };

    function initializeColorSystem() {
      switchPalette('basic');
      updateMixture();
      updatePrimaryColorDisplay();
      initializeColorHistory();
    }

    function updatePrimaryColorDisplay() {
      document.getElementById('primaryColor').style.backgroundColor = currentColor;
    }

    function selectPrimaryColor() {
      // Primary color is already current color
      setColor(currentColor);
    }

    function selectSecondaryColor() {
      const secondaryColor = document.getElementById('secondaryColor').style.backgroundColor || '#ffffff';
      const tempColor = currentColor;
      setColor(secondaryColor);
      document.getElementById('secondaryColor').style.backgroundColor = tempColor;
    }

    function updateHSVFromColor(hex) {
      const rgb = hexToRgb(hex);
      const hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
      
      document.getElementById('hueSlider').value = Math.round(hsv.h);
      document.getElementById('satSlider').value = Math.round(hsv.s);
      document.getElementById('lightSlider').value = Math.round(hsv.v);
      
      document.getElementById('hueValue').textContent = Math.round(hsv.h) + '¬∞';
      document.getElementById('satValue').textContent = Math.round(hsv.s) + '%';
      document.getElementById('lightValue').textContent = Math.round(hsv.v) + '%';
    }

    function updateFromHSV() {
      const h = parseInt(document.getElementById('hueSlider').value);
      const s = parseInt(document.getElementById('satSlider').value);
      const v = parseInt(document.getElementById('lightSlider').value);
      
      document.getElementById('hueValue').textContent = h + '¬∞';
      document.getElementById('satValue').textContent = s + '%';
      document.getElementById('lightValue').textContent = v + '%';
      
      const rgb = hsvToRgb(h, s, v);
      const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
      
      currentColor = hex;
      document.getElementById('colorPicker').value = hex;
      updatePrimaryColorDisplay();
      addToColorHistory(hex);
    }

    function setMixColor(colorNumber) {
      if (colorNumber === 1) {
        mixColor1 = currentColor;
        document.getElementById('mixColor1').style.backgroundColor = currentColor;
      } else {
        mixColor2 = currentColor;
        document.getElementById('mixColor2').style.backgroundColor = currentColor;
      }
      updateMixture();
    }

    function updateMixture() {
      const ratio = parseInt(document.getElementById('mixRatio').value) / 100;
      document.getElementById('mixValue').textContent = Math.round(ratio * 100) + '%';
      
      const color1 = hexToRgb(mixColor1);
      const color2 = hexToRgb(mixColor2);
      
      const mixed = {
        r: Math.round(color1.r * (1 - ratio) + color2.r * ratio),
        g: Math.round(color1.g * (1 - ratio) + color2.g * ratio),
        b: Math.round(color1.b * (1 - ratio) + color2.b * ratio)
      };
      
      const mixedHex = rgbToHex(mixed.r, mixed.g, mixed.b);
      document.getElementById('mixResult').style.backgroundColor = mixedHex;
    }

    function useMixedColor() {
      const mixedColor = document.getElementById('mixResult').style.backgroundColor;
      if (mixedColor.startsWith('rgb')) {
        const hex = rgbToHex(...mixedColor.match(/\d+/g).map(Number));
        setColor(hex);
      } else {
        setColor(mixedColor);
      }
    }

    function addToColorHistory(color) {
      if (!colorHistory.includes(color)) {
        colorHistory.unshift(color);
        if (colorHistory.length > 10) colorHistory.pop();
        updateColorHistoryDisplay();
      }
    }

    function updateColorHistoryDisplay() {
      const historyDiv = document.getElementById('colorHistory');
      historyDiv.innerHTML = '';
      colorHistory.forEach(color => {
        const swatch = document.createElement('div');
        swatch.style.cssText = `width: 20px; height: 20px; background-color: ${color}; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;`;
        swatch.onclick = () => setColor(color);
        swatch.title = color;
        historyDiv.appendChild(swatch);
      });
    }

    function initializeColorHistory() {
      colorHistory = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff'];
      updateColorHistoryDisplay();
    }

    function switchPalette(paletteName) {
      currentPalette = paletteName;
      
      // Update tab styles
      document.querySelectorAll('.palette-tab').forEach(tab => {
        tab.style.backgroundColor = '#f0f0f0';
        tab.style.color = '#333';
      });
      event.target.style.backgroundColor = '#4a90e2';
      event.target.style.color = 'white';
      
      // Update palette display
      const paletteDiv = document.getElementById('colorPalette');
      paletteDiv.innerHTML = '';
      
      colorPalettes[paletteName].forEach(color => {
        const swatch = document.createElement('div');
        swatch.style.cssText = `width: 100%; height: 25px; background-color: ${color}; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;`;
        swatch.onclick = () => setColor(color);
        swatch.title = color;
        paletteDiv.appendChild(swatch);
      });
    }

    // Color Conversion Utilities
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    function rgbToHsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      const diff = max - min;
      const v = max;
      const s = max === 0 ? 0 : diff / max;
      let h = 0;
      
      if (diff !== 0) {
        switch (max) {
          case r: h = (60 * ((g - b) / diff) + 360) % 360; break;
          case g: h = (60 * ((b - r) / diff) + 120) % 360; break;
          case b: h = (60 * ((r - g) / diff) + 240) % 360; break;
        }
      }
      
      return { h: h, s: s * 100, v: v * 100 };
    }

    function hsvToRgb(h, s, v) {
      s /= 100; v /= 100;
      const c = v * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = v - c;
      let r = 0, g = 0, b = 0;
      
      if (0 <= h && h < 60) { r = c; g = x; b = 0; }
      else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
      else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
      else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
      else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
      else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
      
      return {
        r: Math.round((r + m) * 255),
        g: Math.round((g + m) * 255),
        b: Math.round((b + m) * 255)
      };
    }

    // Initialize enhanced color system when page loads
    window.addEventListener('load', initializeColorSystem);
    // ===== End Enhanced Color System =====

    function clearCanvas() {
      if (confirm('Are you sure you want to clear the canvas?')) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }

    function saveCanvas() {
      // Create a temporary canvas with white background
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;

      // Fill with white background
      tempCtx.fillStyle = 'white';
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

      // Draw the original canvas on top
      tempCtx.drawImage(canvas, 0, 0);

      // Create download link
      const link = document.createElement('a');
      link.download = 'my-drawing-' + new Date().getTime() + '.png';
      link.href = tempCanvas.toDataURL();
      link.click();

      // Save drawing to gallery
      saveToGallery(link.href);
    }

    // Voice Assistant Functions
    function toggleVoiceInput() {
      if (!recognition) {
        alert('Voice recognition is not supported in your browser. Please use Chrome, Safari, or Edge.');
        return;
      }

      if (isListening) {
        recognition.stop();
      } else {
        recognition.start();
      }
    }

    function stopListening() {
      isListening = false;
      document.getElementById('voice-btn').classList.remove('voice-recording');
      hideVoiceStatus();
    }

    function toggleAutoSpeak() {
      autoSpeak = !autoSpeak;
      const speakBtn = document.getElementById('speak-btn');

      if (autoSpeak) {
        speakBtn.classList.add('auto-speak-on');
        speakBtn.innerHTML = 'üîä ON';
        speakText('Auto speak enabled. I will now speak all my responses.');
      } else {
        speakBtn.classList.remove('auto-speak-on');
        speakBtn.innerHTML = 'üîä Speak';
        // Stop any current speech
        synthesis.cancel();
      }
    }

    function speakText(text) {
      if (!text || !synthesis) return;

      // Cancel any ongoing speech
      synthesis.cancel();

      // Clean up text for better speech
      const cleanText = text
        .replace(/\n+/g, '. ')
        .replace(/\s+/g, ' ')
        .trim();

      if (cleanText.length > 300) {
        // For long text, speak only the first part
        const shortText = cleanText.substring(0, 250) + '... Check the screen for full details.';
        speak(shortText);
      } else {
        speak(cleanText);
      }
    }

    function speak(text) {
      const utterance = new SpeechSynthesisUtterance(text);

      // Set voice properties
      if (voices.length > 0) {
        utterance.voice = voices[0];
      }
      utterance.rate = 0.9;
      utterance.pitch = 1.1;
      utterance.volume = 0.8;

      utterance.onstart = function() {
        showVoiceStatus('üîä AI is speaking...');
      };

      utterance.onend = function() {
        hideVoiceStatus();
      };

      synthesis.speak(utterance);
    }

    function stripHTML(html) {
      const temp = document.createElement('div');
      temp.innerHTML = html;
      return temp.textContent || temp.innerText || '';
    }

    function showVoiceStatus(message) {
      const status = document.getElementById('voiceStatus');
      status.innerHTML = message;
      status.style.display = 'block';
    }

    function hideVoiceStatus() {
      const status = document.getElementById('voiceStatus');
      status.style.display = 'none';
    }

    async function askAI(type = 'basic') {
      const prompt = document.getElementById("prompt").value;
      const aiResponse = document.getElementById("ai-response");

      if (!prompt.trim()) {
        const message = "Please enter what you'd like to draw!";
        aiResponse.innerHTML = message;
        if (autoSpeak) speakText("Please enter what you'd like to draw!");
        return;
      }

      const loadingMessage = type === 'premium' ? "‚ú® Premium AI analyzing..." : "ü§ñ AI is thinking...";
      aiResponse.innerHTML = loadingMessage;

      try {
        const res = await fetch("/analyze", {
          method: "POST",
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            prompt: prompt,
            feature_type: type === 'premium' ? 'premium' : 'basic'
          })
        });

        const data = await res.json();

        if (data.premium_required) {
          aiResponse.innerHTML = data.suggestion;
          if (autoSpeak) speakText(stripHTML(data.suggestion));
          return;
        }

        // Enhanced AI response with tool suggestions
        let suggestion = data.suggestion;

        // Add specific tool suggestions and drawing steps
        if (prompt.toLowerCase().includes('house') || prompt.toLowerCase().includes('building')) {
          suggestion += "<br><br>üè† <strong>Drawing Steps:</strong><br>1. Use <strong>Rectangle tool</strong> for the main walls<br>2. Use <strong>Triangle tool</strong> for the roof<br>3. Use <strong>Rectangle tool</strong> for windows and door<br>4. Switch to <strong>Pencil tool</strong> to add details like doorknob, window frames";
        } else if (prompt.toLowerCase().includes('sun') || prompt.toLowerCase().includes('ball') || prompt.toLowerCase().includes('circle')) {
          suggestion += "<br><br>‚òÄÔ∏è <strong>Drawing Steps:</strong><br>1. Use <strong>Circle tool</strong> - click and drag from center outward<br>2. Switch to <strong>Pencil tool</strong> for rays or surface details<br>3. Use different brush sizes for varied line thickness";
        } else if (prompt.toLowerCase().includes('tree') || prompt.toLowerCase().includes('mountain')) {
          suggestion += "<br><br>üå≤ <strong>Drawing Steps:</strong><br>1. Use <strong>Triangle tool</strong> for the basic tree/mountain shape<br>2. Use <strong>Rectangle tool</strong> for tree trunk<br>3. Switch to <strong>Pencil tool</strong> for texture, leaves, or rocky details<br>4. Try different brush sizes for varied textures";
        } else if (prompt.toLowerCase().includes('face') || prompt.toLowerCase().includes('person')) {
          suggestion += "<br><br>üòä <strong>Drawing Steps:</strong><br>1. Use <strong>Circle tool</strong> for the head<br>2. Use <strong>Pencil tool</strong> for facial features<br>3. Use <strong>Line tool</strong> for hair or straight edges<br>4. Adjust brush size for fine details";
        } else if (prompt.toLowerCase().includes('car') || prompt.toLowerCase().includes('vehicle')) {
          suggestion += "<br><br>üöó <strong>Drawing Steps:</strong><br>1. Use <strong>Rectangle tool</strong> for the main body<br>2. Use <strong>Circle tool</strong> for wheels<br>3. Use <strong>Line tool</strong> for straight edges<br>4. Use <strong>Pencil tool</strong> for details like bumpers, lights";
        } else if (prompt.toLowerCase().includes('flower') || prompt.toLowerCase().includes('plant')) {
          suggestion += "<br><br>üå∏ <strong>Drawing Steps:</strong><br>1. Use <strong>Circle tool</strong> for flower center<br>2. Use <strong>Pencil tool</strong> for petals (draw curved shapes)<br>3. Use <strong>Line tool</strong> for stem<br>4. Switch to smaller brush size for delicate details";
        } else {
          suggestion += "<br><br>üé® <strong>General Drawing Tips:</strong><br>1. Start with basic shapes: <strong>Circle, Rectangle, Triangle, Line</strong><br>2. Use larger brush sizes for main shapes<br>3. Switch to <strong>Pencil tool</strong> with smaller brush for details<br>4. Use <strong>Eraser tool</strong> to refine and clean up<br>5. Try different colors from the color picker!";
        }

        aiResponse.innerHTML = suggestion;

        // Speak the AI response if auto-speak is enabled
        if (autoSpeak) {
          speakText(stripHTML(suggestion));
        }

      } catch (error) {
        const fallbackMessage = `Try breaking down '${prompt}' into basic shapes like circles, rectangles, and triangles. Start with the main outline and add details gradually!<br><br>üí° <strong>Tip:</strong> Use the shape tools on the right for geometric forms, then switch to Pencil for details.`;
        aiResponse.innerHTML = fallbackMessage;
        if (autoSpeak) speakText(stripHTML(fallbackMessage));
      }
    }

    // Initialize canvas background and save initial state
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    saveState();
    initializeLayers();

    // Initialize layers system
    function initializeLayers() {
      updateLayersList();
      layerCanvases['layer1'] = canvas;
    }

    // Undo/Redo functions
    function saveState() {
      if (undoStack.length >= maxUndoSteps) {
        undoStack.shift();
      }
      undoStack.push(canvas.toDataURL());
      redoStack = [];
      updateUndoRedoButtons();
    }

    function undo() {
      if (undoStack.length > 1) {
        redoStack.push(undoStack.pop());
        const prevState = undoStack[undoStack.length - 1];
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = prevState;
        updateUndoRedoButtons();
      }
    }

    function redo() {
      if (redoStack.length > 0) {
        const nextState = redoStack.pop();
        undoStack.push(nextState);
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = nextState;
        updateUndoRedoButtons();
      }
    }

    function updateUndoRedoButtons() {
      document.getElementById('undoBtn').disabled = undoStack.length <= 1;
      document.getElementById('redoBtn').disabled = redoStack.length === 0;
    }

    // Fill tool implementation
    function floodFill(startX, startY, fillColor) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const startIndex = (startY * canvas.width + startX) * 4;
      const startR = data[startIndex];
      const startG = data[startIndex + 1];
      const startB = data[startIndex + 2];

      const fillR = parseInt(fillColor.substr(1, 2), 16);
      const fillG = parseInt(fillColor.substr(3, 2), 16);
      const fillB = parseInt(fillColor.substr(5, 2), 16);

      if (startR === fillR && startG === fillG && startB === fillB) return;

      const pixelsToCheck = [startX, startY];

      while (pixelsToCheck.length > 0) {
        const y = pixelsToCheck.pop();
        const x = pixelsToCheck.pop();

        if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;

        const currentIndex = (y * canvas.width + x) * 4;
        const currentR = data[currentIndex];
        const currentG = data[currentIndex + 1];
        const currentB = data[currentIndex + 2];

        if (Math.abs(currentR - startR) > fillTolerance ||
            Math.abs(currentG - startG) > fillTolerance ||
            Math.abs(currentB - startB) > fillTolerance) continue;

        data[currentIndex] = fillR;
        data[currentIndex + 1] = fillG;
        data[currentIndex + 2] = fillB;
        data[currentIndex + 3] = 255;

        pixelsToCheck.push(x + 1, y, x - 1, y, x, y + 1, x, y - 1);
      }

      ctx.putImageData(imageData, 0, 0);
    }

    // Eyedropper tool
    function pickColor(x, y) {
      const imageData = ctx.getImageData(x, y, 1, 1);
      const data = imageData.data;
      const hex = '#' + 
        ('00' + data[0].toString(16)).slice(-2) +
        ('00' + data[1].toString(16)).slice(-2) +
        ('00' + data[2].toString(16)).slice(-2);
      setColor(hex);
    }

    // Enhanced shape drawing
    function drawStar(x1, y1, x2, y2) {
      const centerX = x1;
      const centerY = y1;
      const outerRadius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      const innerRadius = outerRadius * 0.4;
      const spikes = 5;

      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.fillStyle = currentColor;
      ctx.lineWidth = brushSize;
      ctx.globalAlpha = document.getElementById('shapeOpacity').value;

      ctx.beginPath();
      for (let i = 0; i < spikes * 2; i++) {
        const angle = (i / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();

      if (document.getElementById('fillShapes').checked) {
        ctx.fill();
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function drawArrow(x1, y1, x2, y2) {
      const headLength = 20;
      const angle = Math.atan2(y2 - y1, x2 - x1);

      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.fillStyle = currentColor;
      ctx.lineWidth = brushSize;
      ctx.globalAlpha = document.getElementById('shapeOpacity').value;

      // Draw line
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      // Draw arrowhead
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Layer management
    function addLayer() {
      const newId = 'layer' + (layers.length + 1);
      layers.push({ id: newId, name: 'Layer ' + (layers.length + 1), visible: true, opacity: 1 });
      updateLayersList();
    }

    function updateLayersList() {
      const layersList = document.getElementById('layersList');
      layersList.innerHTML = '';

      layers.forEach((layer, index) => {
        const layerDiv = document.createElement('div');
        layerDiv.className = 'layer-item' + (layer.id === currentLayerId ? ' active' : '');

        layerDiv.innerHTML = `
          <input type="checkbox" ${layer.visible ? 'checked' : ''} onchange="toggleLayerVisibility('${layer.id}')">
          <input type="text" value="${layer.name}" onchange="renameLayer('${layer.id}', this.value)" onclick="setCurrentLayer('${layer.id}')">
          <div class="layer-controls">
            <button onclick="moveLayer('${layer.id}', -1)" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
            <button onclick="moveLayer('${layer.id}', 1)" ${index === layers.length - 1 ? 'disabled' : ''}>‚Üì</button>
            <button onclick="deleteLayer('${layer.id}')" ${layers.length === 1 ? 'disabled' : ''}>√ó</button>
          </div>
        `;

        layersList.appendChild(layerDiv);
      });
    }

    function setCurrentLayer(layerId) {
      currentLayerId = layerId;
      updateLayersList();
    }

    function toggleLayerVisibility(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if (layer) {
        layer.visible = !layer.visible;
        // Implementation would require proper layer system
      }
    }

    function renameLayer(layerId, newName) {
      const layer = layers.find(l => l.id === layerId);
      if (layer) {
        layer.name = newName;
      }
    }

    function moveLayer(layerId, direction) {
      const index = layers.findIndex(l => l.id === layerId);
      if (index !== -1 && index + direction >= 0 && index + direction < layers.length) {
        [layers[index], layers[index + direction]] = [layers[index + direction], layers[index]];
        updateLayersList();
      }
    }

    function deleteLayer(layerId) {
      if (layers.length > 1) {
        layers = layers.filter(l => l.id !== layerId);
        if (currentLayerId === layerId) {
          currentLayerId = layers[0].id;
        }
        updateLayersList();
      }
    }

    // File operations
    function loadImageFile() {
      document.getElementById('fileInput').click();
    }

    function handleFileLoad(event) {
      const file = event.target.files[0];
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            saveState();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }
    }

    function exportSVG() {
      // Simple SVG export (basic implementation)
      const svgData = `<svg width="${canvas.width}" height="${canvas.height}" xmlns="http://www.w3.org/2000/svg">
        <image href="${canvas.toDataURL()}" width="${canvas.width}" height="${canvas.height}"/>
      </svg>`;

      const blob = new Blob([svgData], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.download = 'drawing-' + new Date().getTime() + '.svg';
      link.href = url;
      link.click();
      URL.revokeObjectURL(url);
    }

    // Enhanced tool functions
    function toggleFillShapes() {
      // Toggle fill mode for shapes
    }

    function setShapeOpacity(value) {
      document.getElementById('opacityDisplay').textContent = Math.round(value * 100) + '%';
    }

    function toggleShortcuts() {
      const shortcuts = document.getElementById('keyboardShortcuts');
      shortcuts.style.display = shortcuts.style.display === 'block' ? 'none' : 'block';
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      if (e.target.tagName === 'INPUT') return;

      if (e.ctrlKey) {
        switch(e.key) {
          case 'z': e.preventDefault(); undo(); break;
          case 'y': e.preventDefault(); redo(); break;
          case 's': e.preventDefault(); saveCanvas(); break;
        }
      } else {
        switch(e.key.toLowerCase()) {
          case 'p': setTool('pencil'); break;
          case 'e': setTool('eraser'); break;
          case 'f': setTool('fill'); break;
          case 'r': setTool('rectangle'); break;
          case 'c': setTool('circle'); break;
          case 'l': setTool('line'); break;
          case 't': setTool('triangle'); break;
          case '[': setBrushSize(Math.max(1, brushSize - 1)); break;
          case ']': setBrushSize(Math.min(50, brushSize + 1)); break;
          case '1': setColor('#000000'); break;
          case '2': setColor('#ff0000'); break;
          case '3': setColor('#00ff00'); break;
          case '4': setColor('#0000ff'); break;
          case '5': setColor('#ffff00'); break;
          case 'v': e.preventDefault(); toggleVoiceInput(); break;
          case 'm': e.preventDefault(); toggleAutoSpeak(); break;
          case 'g': e.preventDefault(); openGallery(); break;
        }
      }
    });

    // Reference image functions
    function loadReference() {
      const imageUrl = document.getElementById('imageUrl').value.trim();
      if (!imageUrl) {
        alert('Please enter an image URL');
        return;
      }

      const referenceImage = document.getElementById('referenceImage');
      const referenceContainer = document.getElementById('reference-container');
      const clearBtn = document.getElementById('clearRefBtn');
      const aiResponse = document.getElementById('ai-response');

      // Show loading state
      aiResponse.innerHTML = "üì∑ Loading reference image...";

      // Test if the image URL is valid
      referenceImage.onload = function() {
        referenceContainer.style.display = 'block';
        clearBtn.style.display = 'inline-block';
        document.getElementById('toggleRefBtn').textContent = 'üëÅÔ∏è Hide';
        aiResponse.innerHTML = "‚úÖ Reference image loaded successfully! You can now trace over it or use it as a guide for your drawing.";
      };

      referenceImage.onerror = function() {
        let errorMessage = '‚ùå Failed to load image. ';
        let suggestions = '';

        // Check if it's a Pinterest URL
        if (imageUrl.includes('pinimg.com') || imageUrl.includes('pinterest.com')) {
          errorMessage += 'Pinterest images often have restrictions that prevent direct loading.';
          suggestions = '<br><br>üîÑ <strong>Try these alternatives:</strong><br>‚Ä¢ Right-click the Pinterest image ‚Üí "Copy image address" ‚Üí try that URL<br>‚Ä¢ Save the image to your device and upload to a free image host like <a href="https://imgur.com" target="_blank">Imgur</a><br>‚Ä¢ Use images from <a href="https://unsplash.com" target="_blank">Unsplash</a>, <a href="https://pixabay.com" target="_blank">Pixabay</a>, or <a href="https://pexels.com" target="_blank">Pexels</a>';
        } else if (imageUrl.includes('instagram.com') || imageUrl.includes('facebook.com') || imageUrl.includes('twitter.com')) {
          errorMessage += 'Social media images often have restrictions.';
          suggestions = '<br><br>üí° <strong>Try instead:</strong><br>‚Ä¢ Save the image and upload to <a href="https://imgur.com" target="_blank">Imgur</a><br>‚Ä¢ Use direct image URLs from sites like <a href="https://unsplash.com" target="_blank">Unsplash</a> or <a href="https://pixabay.com" target="_blank">Pixabay</a>';
        } else {
          errorMessage += 'The image URL might be invalid or have access restrictions.';
          suggestions = '<br><br>‚úÖ <strong>Working image examples:</strong><br>‚Ä¢ <code>https://images.unsplash.com/photo-1234567890/example.jpg</code><br>‚Ä¢ <code>https://i.imgur.com/example.jpg</code><br>‚Ä¢ <code>https://cdn.pixabay.com/photo/example.jpg</code><br><br>üîç <strong>Tips:</strong><br>‚Ä¢ Make sure URL ends with .jpg, .png, .gif, or .webp<br>‚Ä¢ Try right-clicking the image ‚Üí "Copy image address"<br>‚Ä¢ Use free image hosting services if needed';
        }

        aiResponse.innerHTML = errorMessage + suggestions;
      };

      referenceImage.src = imageUrl;
    }

    function clearReference() {
      const referenceContainer = document.getElementById('reference-container');
      const clearBtn = document.getElementById('clearRefBtn');
      const imageUrl = document.getElementById('imageUrl');

      referenceContainer.style.display = 'none';
      clearBtn.style.display = 'none';
      imageUrl.value = '';
    }

    function toggleReference() {
      const referenceImage = document.getElementById('referenceImage');
      const toggleBtn = document.getElementById('toggleRefBtn');

      if (referenceImage.style.visibility === 'hidden') {
        referenceImage.style.visibility = 'visible';
        toggleBtn.textContent = 'üëÅÔ∏è Hide';
      } else {
        referenceImage.style.visibility = 'hidden';
        toggleBtn.textContent = 'üëÅÔ∏è Show';
      }
    }

    function setReferenceOpacity(value) {
      const referenceImage = document.getElementById('referenceImage');
      const opacityLabel = document.getElementById('opacityLabel');

      referenceImage.style.opacity = value;
      opacityLabel.textContent = Math.round(value * 100) + '%';
    }

    function showImageExamples() {
      const examples = [
        'https://images.unsplash.com/photo-1574158622682-e40e69881006?w=400',
        'https://images.unsplash.com/photo-1518717758536-85ae29035b6d?w=400',
        'https://images.unsplash.com/photo-1570831739435-6601aa3fa4fb?w=400',
        'https://images.unsplash.com/photo-1541963463532-d68292c34d19?w=400',
        'https://images.unsplash.com/photo-1560807707-8cc77767d783?w=400'
      ];

      const randomExample = examples[Math.floor(Math.random() * examples.length)];
      document.getElementById('imageUrl').value = randomExample;

      const aiResponse = document.getElementById('ai-response');
      aiResponse.innerHTML = 'üí° <strong>Example loaded!</strong> This is a working image URL from Unsplash. Click "Load Reference" to use it, or replace with your own image URL.<br><br>üéØ <strong>For best results:</strong><br>‚Ä¢ Use direct image URLs (ending in .jpg, .png, etc.)<br>‚Ä¢ Try free image sites like Unsplash, Pixabay, or Imgur<br>‚Ä¢ Avoid social media URLs (Pinterest, Instagram, etc.)';
    }

    // Gallery functions
    function openGallery() {
      const galleryModal = document.getElementById('galleryModal');
      galleryModal.style.display = 'block';
      loadGalleryImages();
    }

    function closeGallery() {
      const galleryModal = document.getElementById('galleryModal');
      galleryModal.style.display = 'none';
    }

    function loadGalleryImages() {
      let galleryImages = JSON.parse(localStorage.getItem('galleryImages') || '[]');
      const galleryGrid = document.getElementById('galleryGrid');
      galleryGrid.innerHTML = '';

      galleryImages.forEach((image, index) => {
        const galleryItem = document.createElement('div');
        galleryItem.className = 'gallery-item';
        galleryItem.innerHTML = `
          <img src="${image}" alt="Drawing">
          <div class="gallery-item-info">Saved on ${new Date().toLocaleDateString()}</div>
        `;
        galleryGrid.appendChild(galleryItem);
      });
    }

    function saveToGallery(imageData) {
      let galleryImages = JSON.parse(localStorage.getItem('galleryImages') || '[]');
      galleryImages.push(imageData);
      localStorage.setItem('galleryImages', JSON.stringify(galleryImages));
    }

    // Handle canvas resize for responsive design
    function resizeCanvas() {
      const container = document.getElementById('result-area');
      const maxWidth = container.clientWidth - 40;
      const maxHeight = container.clientHeight - 40;

      if (maxWidth < canvas.width || maxHeight < canvas.height) {
        canvas.style.width = Math.min(maxWidth, canvas.width) + 'px';
        canvas.style.height = Math.min(maxHeight, canvas.height) + 'px';
      }
    }

    

// ====== Zoom & Pan Controls ======
let scale = 1;          // Current zoom level
const scaleStep = 0.1;  // Zoom increment
const minScale = 0.5;
const maxScale = 3;

let isPanning = false;
let panStartX = 0, panStartY = 0;
let offsetX = 0, offsetY = 0;

function zoomIn() {
  if (scale < maxScale) {
    scale += scaleStep;
    updateCanvasTransform();
  }
}

function zoomOut() {
  if (scale > minScale) {
    scale -= scaleStep;
    updateCanvasTransform();
  }
}

function updateCanvasTransform() {
  canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
  canvas.style.transformOrigin = "top left";
  document.getElementById('zoomLevel').textContent = `${Math.round(scale * 100)}%`;
}

// Pan (Hold Shift + Drag)
canvas.addEventListener('mousedown', e => {
  if (e.shiftKey) {
    isPanning = true;
    panStartX = e.clientX - offsetX;
    panStartY = e.clientY - offsetY;
  }
});

canvas.addEventListener('mousemove', e => {
  if (isPanning) {
    offsetX = e.clientX - panStartX;
    offsetY = e.clientY - panStartY;
    updateCanvasTransform();
  }
});

canvas.addEventListener('mouseup', () => { isPanning = false; });
canvas.addEventListener('mouseleave', () => { isPanning = false; });


// Advanced Features
    let symmetryEnabled = false;
    let symmetryLine = canvas.width / 2;
    let gridEnabled = false;
    let gradientStartColor = '#ff0000';
    let gradientEndColor = '#0000ff';

    // Gradient tool implementation
    function drawGradient(x1, y1, x2, y2) {
      const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
      gradient.addColorStop(0, gradientStartColor);
      gradient.addColorStop(1, gradientEndColor);

      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = gradient;
      ctx.lineWidth = brushSize;
      ctx.globalAlpha = document.getElementById('shapeOpacity').value;

      // Draw gradient rectangle
      ctx.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
      ctx.globalAlpha = 1;
    }

    // Pattern brush implementation
    function drawPattern(x, y) {
      const patterns = ['dots', 'lines', 'crosshatch', 'stipple'];
      const currentPattern = patterns[Math.floor(Math.random() * patterns.length)];

      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.lineWidth = brushSize / 3;

      switch(currentPattern) {
        case 'dots':
          for (let i = 0; i < 5; i++) {
            const dx = (Math.random() - 0.5) * brushSize;
            const dy = (Math.random() - 0.5) * brushSize;
            ctx.beginPath();
            ctx.arc(x + dx, y + dy, 1, 0, 2 * Math.PI);
            ctx.fill();
          }
          break;
        case 'lines':
          for (let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI;
            const length = brushSize;
            ctx.beginPath();
            ctx.moveTo(x - Math.cos(angle) * length/2, y - Math.sin(angle) * length/2);
            ctx.lineTo(x + Math.cos(angle) * length/2, y + Math.sin(angle) * length/2);
            ctx.stroke();
          }
          break;
        case 'crosshatch':
          const size = brushSize / 2;
          ctx.beginPath();
          ctx.moveTo(x - size, y - size);
          ctx.lineTo(x + size, y + size);
          ctx.moveTo(x - size, y + size);
          ctx.lineTo(x + size, y - size);
          ctx.stroke();
          break;
        case 'stipple':
          for (let i = 0; i < 8; i++) {
            const dx = (Math.random() - 0.5) * brushSize;
            const dy = (Math.random() - 0.5) * brushSize;
            ctx.fillRect(x + dx, y + dy, 1, 1);
          }
          break;
      }
    }

    // Symmetry mode
    function toggleSymmetry() {
      symmetryEnabled = !symmetryEnabled;
      const btn = document.getElementById('symmetry');

      if (symmetryEnabled) {
        btn.classList.add('symmetry-active');
        showSymmetryLine();
      } else {
        btn.classList.remove('symmetry-active');
        hideSymmetryLine();
      }
    }

    function showSymmetryLine() {
      const line = document.createElement('div');
      line.id = 'symmetryLine';
      line.className = 'symmetry-line';
      line.style.left = (canvas.offsetLeft + symmetryLine) + 'px';
      line.style.top = canvas.offsetTop + 'px';
      line.style.width = '2px';
      line.style.height = canvas.height + 'px';
      document.getElementById('result-area').appendChild(line);
    }

    function hideSymmetryLine() {
      const line = document.getElementById('symmetryLine');
      if (line) line.remove();
    }

    // Grid system
    function toggleGrid() {
      gridEnabled = !gridEnabled;
      const btn = document.getElementById('grid');

      if (gridEnabled) {
        btn.classList.add('grid-active');
        showPerspectiveGrid();
      } else {
        btn.classList.remove('grid-active');
        hidePerspectiveGrid();
      }
    }

    function showPerspectiveGrid() {
      const gridCanvas = document.createElement('canvas');
      gridCanvas.id = 'perspectiveGrid';
      gridCanvas.className = 'perspective-grid';
      gridCanvas.width = canvas.width;
      gridCanvas.height = canvas.height;
      gridCanvas.style.width = canvas.style.width;
      gridCanvas.style.height = canvas.style.height;

      const gridCtx = gridCanvas.getContext('2d');
      gridCtx.strokeStyle = 'rgba(0, 0, 255, 0.3)';
      gridCtx.lineWidth = 1;

      // Draw grid lines
      const gridSize = 50;
      for (let x = 0; x <= canvas.width; x += gridSize) {
        gridCtx.beginPath();
        gridCtx.moveTo(x, 0);
        gridCtx.lineTo(x, canvas.height);
        gridCtx.stroke();
      }

      for (let y = 0; y <= canvas.height; y += gridSize) {
        gridCtx.beginPath();
        gridCtx.moveTo(0, y);
        gridCtx.lineTo(canvas.width, y);
        gridCtx.stroke();
      }

      document.getElementById('result-area').appendChild(gridCanvas);
    }

    function hidePerspectiveGrid() {
      const grid = document.getElementById('perspectiveGrid');
      if (grid) grid.remove();
    }

    // AI Analysis Functions
    async function analyzeDrawing() {
      const imageData = canvas.toDataURL();
      const aiResponse = document.getElementById('ai-response');

      aiResponse.innerHTML = "ü§ñ Analyzing your artwork...";

      try {
        const analysis = await PremiumFeatures.PremiumAI.analyzeComposition(imageData);

        let response = `üé® <strong>AI Art Analysis</strong><br><br>`;
        response += `üìä <strong>Tonal Balance:</strong> ${analysis.balance}<br>`;
        response += `üí° <strong>Light Areas:</strong> ${analysis.brightRatio}%<br>`;
        response += `üåë <strong>Dark Areas:</strong> ${analysis.darkRatio}%<br><br>`;
        response += `üéØ <strong>Focus Points:</strong> ${analysis.focusPoints.join(', ')}<br><br>`;
        response += `‚ú® <strong>Suggestions:</strong><br>`;
        analysis.suggestions.forEach(suggestion => {
          response += `‚Ä¢ ${suggestion}<br>`;
        });

        aiResponse.innerHTML = response;

        if (autoSpeak) {
          speakText(`Your artwork has ${analysis.balance} tonal balance. ${analysis.suggestions[0]}`);
        }

      } catch (error) {
        aiResponse.innerHTML = "üé® <strong>Quick Analysis:</strong><br>Your drawing shows good use of space! Consider adding more contrast between light and dark areas for visual impact.";
      }
    }

    async function suggestColors() {
      const imageData = canvas.toDataURL();
      const aiResponse = document.getElementById('ai-response');

      aiResponse.innerHTML = "üé® Generating color palette...";

      try {
        const palette = await PremiumFeatures.PremiumAI.suggestColorPalette(imageData);

        let response = `üåà <strong>AI Color Palette</strong><br><br>`;
        response += `üéØ <strong>Primary Color:</strong> <span style="background-color: ${palette.primary}; padding: 2px 8px; color: white;">${palette.primary}</span><br>`;
        response += `üî∏ <strong>Secondary:</strong> <span style="background-color: ${palette.secondary}; padding: 2px 8px; color: white;">${palette.secondary}</span><br>`;
        response += `‚ú® <strong>Accent:</strong> <span style="background-color: ${palette.accent}; padding: 2px 8px; color: white;">${palette.accent}</span><br><br>`;
        response += `üé® <strong>Color Suggestions:</strong><br>`;
        palette.suggestions.forEach(suggestion => {
          response += `‚Ä¢ ${suggestion}<br>`;
        });

        // Add clickable color swatches
        response += `<br><strong>Click to use colors:</strong><br>`;
        response += `<span style="display: inline-block; width: 30px; height: 30px; background-color: ${palette.primary}; margin: 2px; cursor: pointer; border: 1px solid #ccc;" onclick="setColor('${palette.primary}')" title="Primary"></span>`;
        response += `<span style="display: inline-block; width: 30px; height: 30px; background-color: ${palette.secondary}; margin: 2px; cursor: pointer; border: 1px solid #ccc;" onclick="setColor('${palette.secondary}')" title="Secondary"></span>`;
        response += `<span style="display: inline-block; width: 30px; height: 30px; background-color: ${palette.accent}; margin: 2px; cursor: pointer; border: 1px solid #ccc;" onclick="setColor('${palette.accent}')" title="Accent"></span>`;

        if (palette.complementary && palette.complementary.length > 0) {
          palette.complementary.forEach((color, index) => {
            response += `<span style="display: inline-block; width: 30px; height: 30px; background-color: ${color}; margin: 2px; cursor: pointer; border: 1px solid #ccc;" onclick="setColor('${color}')" title="Complementary ${index + 1}"></span>`;
          });
        }

        aiResponse.innerHTML = response;

        if (autoSpeak) {
          speakText(`I've generated a color palette for your artwork. Try using ${palette.primary} as your primary color.`);
        }

      } catch (error) {
        aiResponse.innerHTML = "üé® <strong>Color Suggestions:</strong><br>Try using complementary colors like blue and orange, or red and green for strong contrast. Analogous colors (colors next to each other on the color wheel) create harmony.";
      }
    }

    // PDF Export function
    function exportPDF() {
      // Simple PDF export using canvas
      const link = document.createElement('a');
      link.download = 'drawing-' + new Date().getTime() + '.pdf';

      // For a more complete PDF solution, you'd use jsPDF library
      // For now, we'll export as high-quality PNG
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = canvas.width * 2; // Higher resolution
      tempCanvas.height = canvas.height * 2;

      tempCtx.scale(2, 2);
      tempCtx.fillStyle = 'white';
      tempCtx.fillRect(0, 0, canvas.width, canvas.height);
      tempCtx.drawImage(canvas, 0, 0);

      link.href = tempCanvas.toDataURL();
      link.click();
    }

    // Enhanced drawing functions with new tools
    function draw(e) {
      if (!isDrawing) return;

      const pos = getMousePos(e);

      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      if (currentTool === 'pencil') {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = currentColor;
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();

        // Mirror drawing if symmetry is enabled
        if (symmetryEnabled) {
          const mirrorX = symmetryLine * 2 - pos.x;
          ctx.lineTo(mirrorX, pos.y);
          ctx.stroke();
        }
      } else if (currentTool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();

        if (symmetryEnabled) {
          const mirrorX = symmetryLine * 2 - pos.x;
          ctx.lineTo(mirrorX, pos.y);
          ctx.stroke();
        }
      } else if (currentTool === 'pattern') {
        drawPattern(pos.x, pos.y);

        if (symmetryEnabled) {
          const mirrorX = symmetryLine * 2 - pos.x;
          drawPattern(mirrorX, pos.y);
        }
      }
    }

    // Update stopDrawing for new tools
    function stopDrawing(e) {
      if (!isDrawing) return;

      const pos = getMousePos(e);

      if (currentTool === 'rectangle') {
        drawRectangle(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawRectangle(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'circle') {
        drawCircle(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawCircle(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'line') {
        drawLine(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawLine(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'triangle') {
        drawTriangle(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawTriangle(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'star') {
        drawStar(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawStar(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'arrow') {
        drawArrow(startX, startY, pos.x, pos.y);
        if (symmetryEnabled) {
          const mirrorStartX = symmetryLine * 2 - startX;
          const mirrorEndX = symmetryLine * 2 - pos.x;
          drawArrow(mirrorStartX, startY, mirrorEndX, pos.y);
        }
        saveState();
      } else if (currentTool === 'gradient') {
        drawGradient(startX, startY, pos.x, pos.y);
        saveState();
      }

      isDrawing = false;
      ctx.beginPath();
    }

    // Call resize on load and window resize
    window.addEventListener('load', resizeCanvas);
    window.addEventListener('resize', resizeCanvas);

    // Prevent scrolling when touching the canvas
    document.body.addEventListener('touchstart', function (e) {
      if (e.target === canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    document.body.addEventListener('touchend', function (e) {
      if (e.target === canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    document.body.addEventListener('touchmove', function (e) {
      if (e.target === canvas) {
        e.preventDefault();
      }
    }, { passive: false });

        // Voice Assistant Functions (moved to the top)
    function toggleVoiceInput() {
      if (!recognition) {
        alert('Voice recognition is not supported in your browser. Please use Chrome, Safari, or Edge.');
        return;
      }

      if (isListening) {
        recognition.stop();
      } else {
        recognition.start();
      }
    }

    function stopListening() {
      isListening = false;
      document.getElementById('voice-btn').classList.remove('voice-recording');
      hideVoiceStatus();
    }

    function toggleAutoSpeak() {
      autoSpeak = !autoSpeak;
      const speakBtn = document.getElementById('speak-btn');

      if (autoSpeak) {
        speakBtn.classList.add('auto-speak-on');
        speakBtn.innerHTML = 'üîä ON';
        speakText('Auto speak enabled. I will now speak all my responses.');
      } else {
        speakBtn.classList.remove('auto-speak-on');
        speakBtn.innerHTML = 'üîä Speak';
        // Stop any current speech
        synthesis.cancel();
      }
    }

    function speakText(text) {
      if (!text || !synthesis) return;

      // Cancel any ongoing speech
      synthesis.cancel();

      // Clean up text for better speech
      const cleanText = text
        .replace(/\n+/g, '. ')
        .replace(/\s+/g, ' ')
        .trim();

      if (cleanText.length > 300) {
        // For long text, speak only the first part
        const shortText = cleanText.substring(0, 250) + '... Check the screen for full details.';
        speak(shortText);
      } else {
        speak(cleanText);
      }
    }

    function speak(text) {
      const utterance = new SpeechSynthesisUtterance(text);

      // Set voice properties
      if (voices.length > 0) {
        utterance.voice = voices[0];
      }
      utterance.rate = 0.9;
      utterance.pitch = 1.1;
      utterance.volume = 0.8;

      utterance.onstart = function() {
        showVoiceStatus('üîä AI is speaking...');
      };

      utterance.onend = function() {
        hideVoiceStatus();
      };

      synthesis.speak(utterance);
    }

    function stripHTML(html) {
      const temp = document.createElement('div');
      temp.innerHTML = html;
      return temp.textContent || temp.innerText || '';
    }

    function showVoiceStatus(message) {
      const status = document.getElementById('voiceStatus');
      status.innerHTML = message;
      status.style.display = 'block';
    }

    function hideVoiceStatus() {
      const status = document.getElementById('voiceStatus');
      status.style.display = 'none';
    }
    async function askAI(type = 'basic') {
      const prompt = document.getElementById("prompt").value;
      const aiResponse = document.getElementById("ai-response");

      if (!prompt.trim()) {
        const message = "Please enter what you'd like to draw!";
        aiResponse.innerHTML = message;
        if (autoSpeak) speakText("Please enter what you'd like to draw!");
        return;
      }

      const loadingMessage = type === 'premium' ? "‚ú® Premium AI analyzing..." : "ü§ñ AI is thinking...";
      aiResponse.innerHTML = loadingMessage;

      try {
        const res = await fetch("/analyze", {
          method: "POST",
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            prompt: prompt,
            feature_type: type === 'premium' ? 'premium' : 'basic'
          })
        });

        const data = await res.json();

        if (data.premium_required) {
          aiResponse.innerHTML = data.suggestion;
          if (autoSpeak) speakText(stripHTML(data.suggestion));
          return;
        }

        // Enhanced AI response with tool suggestions
        let suggestion = data.suggestion;

        // Add specific tool suggestions and drawing steps
        if (prompt.toLowerCase().includes('house') || prompt.toLowerCase().includes('building')) {
          suggestion += "<br><br>üè† <strong>Drawing Steps:</strong><br>1. Use <strong>Rectangle tool</strong> for the main walls<br>2. Use <strong>Triangle tool</strong> for the roof<br>3. Use <strong>Rectangle tool</strong> for windows and door<br>4. Switch to <strong>Pencil tool</strong> to add details like doorknob, window frames";
        } else if (prompt.toLowerCase().includes('sun') || prompt.toLowerCase().includes('ball') || prompt.toLowerCase().includes('circle')) {
          suggestion += "<br><br>‚òÄÔ∏è <strong>Drawing Steps:</strong><br>1. Use <strong>Circle tool</strong> - click and drag from center outward<br>2. Switch to <strong>Pencil tool</strong> for rays or surface details<br>3. Use different brush sizes for varied line thickness";
        } else if (prompt.toLowerCase().includes('tree') || prompt.toLowerCase().includes('mountain')) {
          suggestion += "<br><br>üå≤ <strong>Drawing Steps:</strong><br>1. Use <strong>Triangle tool</strong> for the basic tree/mountain shape<br>2. Use <strong>Rectangle tool</strong> for tree trunk<br>3. Switch to <strong>Pencil tool</strong> for texture, leaves, or rocky details<br>4. Try different brush sizes for varied textures";
        } else if (prompt.toLowerCase().includes('face') || prompt.toLowerCase().includes('person')) {
          suggestion += "<br><br>üòä <strong>Drawing Steps:</strong><br>1. Use <strong>Circle tool</strong> for the head<br>2. Use <strong>Pencil tool</strong> for facial features<br>3. Use <strong>Line tool</strong> for hair or straight edges<br>4. Adjust brush size for fine details";
        } else if (prompt.toLowerCase().includes('car') || prompt.toLowerCase().includes('vehicle')) {
          suggestion += "<br><br>üöó <strong>Drawing Steps:</strong><br>1. Use <strong>Rectangle tool</strong> for the main body<br>2. Use <strong>Circle tool</strong> for wheels<br>3. Use <strong>Line tool</strong> for straight edges<br>4. Use <strong>Pencil tool</strong> for details like bumpers, lights";
        } else if (prompt.toLowerCase().includes('flower') || prompt.toLowerCase().includes('plant')) {
          suggestion += "<br><br>üå∏ <strong>Drawing Steps:</strong><br>1. Use <strong>Circle tool</strong> for flower center<br>2. Use <strong>Pencil tool</strong> for petals (draw curved shapes)<br>3. Use <strong>Line tool</strong> for stem<br>4. Switch to smaller brush size for delicate details";
        } else {
          suggestion += "<br><br>üé® <strong>General Drawing Tips:</strong><br>1. Start with basic shapes: <strong>Circle, Rectangle, Triangle, Line</strong><br>2. Use larger brush sizes for main shapes<br>3. Switch to <strong>Pencil tool</strong> with smaller brush for details<br>4. Use <strong>Eraser tool</strong> to refine and clean up<br>5. Try different colors from the color picker!";
        }

        aiResponse.innerHTML = suggestion;

        // Speak the AI response if auto-speak is enabled
        if (autoSpeak) {
          speakText(stripHTML(suggestion));
        }

      } catch (error) {
        const fallbackMessage = `Try breaking down '${prompt}' into basic shapes like circles, rectangles, and triangles. Start with the main outline and add details gradually!<br><br>üí° <strong>Tip:</strong> Use the shape tools on the right for geometric forms, then switch to Pencil for details.`;
        aiResponse.innerHTML = fallbackMessage;
        if (autoSpeak) speakText(stripHTML(fallbackMessage));
      }
    }
  </script>

<!-- ===== Inline Modern Cropper (mc- prefixed, no overlay) ===== -->
<style>
  #mc-cropper-section { display:none; padding: 8px 10px 16px; }
  #mc-topbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:10px; }
  #mc-topbar .mc-btn { appearance:none; border:1px solid #e5e7eb; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
  #mc-topbar .primary { background:#4a90e2; color:#fff; border-color:#4a90e2; }
  #mc-topbar select, #mc-topbar input[type=range] { border:1px solid #e5e7eb; border-radius:10px; padding:6px 8px; background:#fff; }

  #mc-stage-wrap { position: relative; width: 100%; height: 65vh; min-height: 320px; background: #111; border-radius: 12px; overflow: hidden; box-shadow: 0 8px 30px rgba(0,0,0,0.15); }
  #mc-stage { width:100%; height:100%; display:block; background: repeating-conic-gradient(#eee 0% 25%, #ddd 0% 50%) 50% / 20px 20px; touch-action:none; user-select:none; }

  #mc-dim { position:absolute; inset:0; background:rgba(0,0,0,.45); pointer-events:none; }
  #mc-crop { position:absolute; border:2px solid #4a90e2; box-shadow:0 0 0 9999px rgba(0,0,0,.55); touch-action:none; }

  .mc-handle { position:absolute; width:14px; height:14px; border-radius:50%; background:#fff; border:2px solid #4a90e2; box-shadow:0 2px 6px rgba(0,0,0,.25); }
  .mc-handle.nw{ top:-7px; left:-7px; cursor:nwse-resize;} .mc-handle.ne{ top:-7px; right:-7px; cursor:nesw-resize;}
  .mc-handle.sw{ bottom:-7px; left:-7px; cursor:nesw-resize;} .mc-handle.se{ bottom:-7px; right:-7px; cursor:nwse-resize;}
  .mc-handle.n{ top:-7px; left:calc(50% - 7px); cursor:ns-resize;} .mc-handle.s{ bottom:-7px; left:calc(50% - 7px); cursor:ns-resize;}
  .mc-handle.w{ left:-7px; top:calc(50% - 7px); cursor:ew-resize;} .mc-handle.e{ right:-7px; top:calc(50% - 7px); cursor:ew-resize;}

  /* Responsive: buttons align like a keyboard row on phones */
  @media (max-width: 768px) {
    #mc-topbar { gap:6px; }
    #mc-topbar .mc-btn, #mc-topbar select, #mc-topbar input[type=range] { flex: 1 1 calc(50% - 8px); }
    #mc-stage-wrap { height: 58vh; min-height: 260px; border-radius: 10px; }
  }
</style>

<section id="mc-cropper-section">
  <div id="mc-topbar">
    <button id="mc-close" class="mc-btn">‚úñ Close</button>
    <button id="mc-apply" class="mc-btn primary">‚úî Apply</button>
    <button id="mc-load" class="mc-btn">üìÇ Load</button>
    <button id="mc-reset" class="mc-btn">‚Ü∫ Reset</button>
    <button id="mc-download" class="mc-btn">‚¨á Download</button>

    <label>Aspect
      <select id="mc-aspect">
        <option value="free">Free</option>
        <option value="1:1">1:1</option>
        <option value="4:3">4:3</option>
        <option value="3:4">3:4</option>
        <option value="16:9">16:9</option>
        <option value="9:16">9:16</option>
      </select>
    </label>

    <label>Zoom
      <input id="mc-zoom" type="range" min="0.25" max="3" step="0.01" value="1">
    </label>

    <button id="mc-rot" class="mc-btn">‚§æ Rotate 90¬∞</button>
    <button id="mc-fliph" class="mc-btn">‚áã Flip H</button>
    <button id="mc-flipv" class="mc-btn">‚áÖ Flip V</button>
  </div>

  <div id="mc-stage-wrap">
    <canvas id="mc-stage" width="900" height="560"></canvas>
    <div id="mc-dim"></div>
    <div id="mc-crop" style="left:20%; top:20%; width:60%; height:60%;">
      <div class="mc-handle nw" data-h="nw"></div>
      <div class="mc-handle ne" data-h="ne"></div>
      <div class="mc-handle sw" data-h="sw"></div>
      <div class="mc-handle se" data-h="se"></div>
      <div class="mc-handle n" data-h="n"></div>
      <div class="mc-handle s" data-h="s"></div>
      <div class="mc-handle w" data-h="w"></div>
      <div class="mc-handle e" data-h="e"></div>
    </div>
  </div>
</section>

<script>
// ===== Inline Modern Cropper Logic (isolated & prefixed) =====
(function(){
  // References to the drawing app
  const srcCanvas = document.getElementById('canvas');
  const srcCtx = srcCanvas ? srcCanvas.getContext('2d') : null;

  // Cropper DOM
  const section = document.getElementById('mc-cropper-section');
  const stage = document.getElementById('mc-stage');
  const ctx = stage.getContext('2d');
  const cropEl = document.getElementById('mc-crop');
  const aspectSel = document.getElementById('mc-aspect');
  const zoomRange = document.getElementById('mc-zoom');
  const btnApply = document.getElementById('mc-apply');
  const btnClose = document.getElementById('mc-close');
  const btnRot = document.getElementById('mc-rot');
  const btnFlipH = document.getElementById('mc-fliph');
  const btnFlipV = document.getElementById('mc-flipv');
  const btnLoad = document.getElementById('mc-load');
  const btnReset = document.getElementById('mc-reset');
  const btnDownload = document.getElementById('mc-download');

  const fileInput = document.createElement('input');
  fileInput.type = 'file'; fileInput.accept = 'image/*';

  // State
  let img = new Image();
  let imgLoaded = false;
  let baseImgDataURL = null;
  let scale = 1, offsetX = 0, offsetY = 0;
  let rotation = 0, flipH = 0, flipV = 0;
  let isPanning = false, panStart = {x:0,y:0}, panStartOff = {x:0,y:0};
  let hasInitialFromCanvas = false;

  // Public: open cropper (called by crop button)
  window.mc_openCropper = function(){
    // snapshot current drawing canvas by default
    if(srcCanvas){
      baseImgDataURL = srcCanvas.toDataURL('image/png');
      hasInitialFromCanvas = true;
      loadFromDataURL(baseImgDataURL);
    }
    section.style.display = 'block';
    fitStage();
  };

  function mc_closeCropper(){
    section.style.display = 'none';
  }

  function loadFromDataURL(dataURL){
    img = new Image();
    img.onload = ()=>{
      imgLoaded = true;
      fitStage(); fitImageToStage(); render(); setCropBox(0.2,0.2,0.6,0.6);
    };
    img.src = dataURL;
  }

  function fitStage(){
    const wrap = document.getElementById('mc-stage-wrap').getBoundingClientRect();
    stage.width = Math.round(wrap.width);
    stage.height = Math.round(wrap.height);
  }

  function fitImageToStage(){
    if(!img) return;
    const s = Math.min(stage.width / img.width, stage.height / img.height);
    scale = s;
    offsetX = (stage.width - img.width * scale)/2;
    offsetY = (stage.height - img.height * scale)/2;
    zoomRange.value = s.toFixed(2);
    rotation = 0; flipH = 0; flipV = 0;
  }

  function render(){
    ctx.clearRect(0,0,stage.width,stage.height);
    ctx.save();
    const cx = stage.width/2, cy = stage.height/2;
    ctx.translate(cx, cy);
    ctx.rotate(rotation * Math.PI/2);
    ctx.scale(flipH? -1:1, flipV? -1:1);
    ctx.translate(-cx, -cy);
    ctx.imageSmoothingEnabled = true;
    if(imgLoaded){
      ctx.drawImage(img, 0,0, img.width, img.height, offsetX, offsetY, img.width*scale, img.height*scale);
    }
    ctx.restore();
  }

  // Mapping
  function getCropBoxCanvasRect(){
    const rect = stage.getBoundingClientRect();
    const c = cropEl.getBoundingClientRect();
    const x = (c.left - rect.left) * (stage.width / rect.width);
    const y = (c.top - rect.top) * (stage.height / rect.height);
    const w = c.width * (stage.width / rect.width);
    const h = c.height * (stage.height / rect.height);
    return {x,y,w,h};
  }
  function canvasToImagePoint(x,y){
    const cx = stage.width/2, cy = stage.height/2;
    let dx = x - cx, dy = y - cy;
    let rx = dx, ry = dy;
    const k = (4 - (rotation % 4) + 4) % 4;
    for(let i=0;i<k;i++){ const tx = ry; const ty = -rx; rx = tx; ry = ty; }
    rx = (flipH ? -rx : rx);
    ry = (flipV ? -ry : ry);
    const ux = rx + cx, uy = ry + cy;
    const ix = (ux - offsetX) / scale;
    const iy = (uy - offsetY) / scale;
    return {ix, iy};
  }

  // Buttons
  btnClose.addEventListener('click', mc_closeCropper);

  btnApply.addEventListener('click', ()=>{
    if(!imgLoaded || !srcCtx) return;
    const {x,y,w,h} = getCropBoxCanvasRect();
    const p1 = canvasToImagePoint(x,y);
    const p2 = canvasToImagePoint(x+w, y+h);
    const sx = Math.min(p1.ix, p2.ix), sy = Math.min(p1.iy, p2.iy);
    const sw = Math.abs(p2.ix - p1.ix), sh = Math.abs(p2.iy - p1.iy);
    const sxC = Math.max(0, Math.min(img.width, sx));
    const syC = Math.max(0, Math.min(img.height, sy));
    const swC = Math.max(1, Math.min(img.width - sxC, sw));
    const shC = Math.max(1, Math.min(img.height - syC, sh));

    const out = document.createElement('canvas');
    out.width = Math.round(swC); out.height = Math.round(shC);
    const octx = out.getContext('2d');
    octx.imageSmoothingEnabled = true;
    octx.drawImage(img, sxC, syC, swC, shC, 0,0, out.width, out.height);

    // Replace original canvas content & size
    srcCanvas.width = out.width;
    srcCanvas.height = out.height;
    srcCtx.drawImage(out, 0, 0);

    mc_closeCropper();
  });

  btnLoad.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', (e)=>{
    const file = e.target.files && e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
      baseImgDataURL = ev.target.result;
      hasInitialFromCanvas = false;
      loadFromDataURL(baseImgDataURL);
    };
    reader.readAsDataURL(file);
    fileInput.value = "";
  });

  btnReset.addEventListener('click', ()=>{
    if(baseImgDataURL){ loadFromDataURL(baseImgDataURL); }
  });

  btnDownload.addEventListener('click', ()=>{
    if(!imgLoaded) return;
    const {x,y,w,h} = getCropBoxCanvasRect();
    const p1 = canvasToImagePoint(x,y);
    const p2 = canvasToImagePoint(x+w, y+h);
    const sx = Math.min(p1.ix, p2.ix), sy = Math.min(p1.iy, p2.iy);
    const sw = Math.abs(p2.ix - p1.ix), sh = Math.abs(p2.iy - p1.iy);
    const sxC = Math.max(0, Math.min(img.width, sx));
    const syC = Math.max(0, Math.min(img.height, sy));
    const swC = Math.max(1, Math.min(img.width - sxC, sw));
    const shC = Math.max(1, Math.min(img.height - syC, sh));

    const out = document.createElement('canvas');
    out.width = Math.round(swC); out.height = Math.round(shC);
    out.getContext('2d').drawImage(img, sxC, syC, swC, shC, 0,0, out.width, out.height);
    const a = document.createElement('a');
    a.href = out.toDataURL('image/png');
    a.download = 'cropped.png';
    a.click();
  });

  // Interactions: pan/zoom/rotate/flip
  zoomRange.addEventListener('input', (e)=>{
    if(!imgLoaded) return;
    const newScale = parseFloat(e.target.value);
    const cx = stage.width/2, cy = stage.height/2;
    const p = canvasToImagePoint(cx, cy);
    scale = newScale;
    const ux = p.ix * scale + offsetX, uy = p.iy * scale + offsetY;
    offsetX += (cx - ux); offsetY += (cy - uy);
    render();
  });
  btnRot.addEventListener('click', ()=>{ rotation = (rotation+1)%4; render(); });
  btnFlipH.addEventListener('click', ()=>{ flipH ^= 1; render(); });
  btnFlipV.addEventListener('click', ()=>{ flipV ^= 1; render(); });

  stage.addEventListener('mousedown', (e)=>{
    const c = cropEl.getBoundingClientRect();
    if(e.clientX < c.left || e.clientX > c.right || e.clientY < c.top || e.clientY > c.bottom){
      isPanning = true;
      panStart.x = e.clientX; panStart.y = e.clientY;
      panStartOff.x = offsetX; panStartOff.y = offsetY;
    }
  });
  window.addEventListener('mousemove', (e)=>{
    if(!isPanning) return;
    offsetX = panStartOff.x + (e.clientX - panStart.x);
    offsetY = panStartOff.y + (e.clientY - panStart.y);
    render();
  });
  window.addEventListener('mouseup', ()=>{ isPanning = false; });

  // Crop box drag & handles
  let isDraggingCrop = false, dragStart={x:0,y:0}, cropStart={x:0,y:0,w:0,h:0}, activeHandle=null;

  function setCropBox(lPerc, tPerc, wPerc, hPerc){
    cropEl.style.left = (lPerc*100)+'%';
    cropEl.style.top = (tPerc*100)+'%';
    cropEl.style.width = (wPerc*100)+'%';
    cropEl.style.height = (hPerc*100)+'%';
  }
  function clampCropToStage(){
    const s = document.getElementById('mc-stage-wrap').getBoundingClientRect();
    const c = cropEl.getBoundingClientRect();
    let left = c.left - s.left, top = c.top - s.top, width = c.width, height = c.height;
    if(left < 0) left = 0; if(top < 0) top = 0;
    if(left + width > s.width) left = s.width - width;
    if(top + height > s.height) top = s.height - height;
    cropEl.style.left = (left / s.width * 100) + '%';
    cropEl.style.top  = (top  / s.height * 100) + '%';
    cropEl.style.width = (width / s.width * 100) + '%';
    cropEl.style.height= (height/ s.height * 100) + '%';
  }
  function onCropDragStart(e, handle=null){
    e.preventDefault();
    activeHandle = handle;
    isDraggingCrop = true;
    const s = document.getElementById('mc-stage-wrap').getBoundingClientRect();
    const c = cropEl.getBoundingClientRect();
    cropStart = {x:c.left - s.left, y:c.top - s.top, w:c.width, h:c.height};
    dragStart.x = (e.touches? e.touches[0].clientX : e.clientX);
    dragStart.y = (e.touches? e.touches[0].clientY : e.clientY);
  }
  function onCropDragMove(e){
    if(!isDraggingCrop) return;
    const clientX = (e.touches? e.touches[0].clientX : e.clientX);
    const clientY = (e.touches? e.touches[0].clientY : e.clientY);
    const dx = clientX - dragStart.x, dy = clientY - dragStart.y;

    const s = document.getElementById('mc-stage-wrap').getBoundingClientRect();
    let left = cropStart.x, top = cropStart.y, width = cropStart.w, height = cropStart.h;

    const keepAspect = aspectSel.value !== 'free';
    let ratio = null;
    if (keepAspect) { const [aw,ah] = aspectSel.value.split(':').map(Number); ratio = aw/ah; }

    if(!activeHandle){
      left += dx; top += dy;
    } else {
      const fromRight = (activeHandle.includes('e') || activeHandle === 'e');
      const fromLeft  = (activeHandle.includes('w') || activeHandle === 'w');
      const fromTop   = (activeHandle.includes('n') || activeHandle === 'n');
      const fromBot   = (activeHandle.includes('s') || activeHandle === 's');

      let newLeft = left, newTop=top, newW=width, newH=height;
      if(!keepAspect){
        if(fromLeft){ newLeft = left + dx; newW = width - dx; }
        if(fromRight){ newW = width + dx; }
        if(fromTop){ newTop = top + dy; newH = height - dy; }
        if(fromBot){ newH = height + dy; }
      } else {
        const domDX = (fromLeft ? -dx : (fromRight ? dx : 0));
        const domDY = (fromTop ? -dy : (fromBot ? dy : 0));
        if(Math.abs(domDX) > Math.abs(domDY)){
          let wChange = domDX;
          if(fromLeft){ newLeft = left - wChange; }
          newW = width + wChange;
          newH = newW / ratio;
          if(fromTop){ newTop = top + (height - newH); }
        } else {
          let hChange = domDY;
          if(fromTop){ newTop = top - hChange; }
          newH = height + hChange;
          newW = newH * ratio;
          if(fromLeft){ newLeft = left + (width - newW); }
        }
      }
      const min = 30;
      width = Math.max(min, newW);
      height = Math.max(min, newH);
      left = newLeft; top = newTop;
    }
    cropEl.style.left = (left / s.width * 100) + '%';
    cropEl.style.top  = (top  / s.height * 100) + '%';
    cropEl.style.width = (width / s.width * 100) + '%';
    cropEl.style.height= (height/ s.height * 100) + '%';
    clampCropToStage();
  }
  function onCropDragEnd(){ isDraggingCrop = false; activeHandle = null; }

  cropEl.addEventListener('mousedown', (e)=>{ if((e.target).classList.contains('mc-handle')) return; onCropDragStart(e, null); });
  window.addEventListener('mousemove', onCropDragMove);
  window.addEventListener('mouseup', onCropDragEnd);
  cropEl.addEventListener('touchstart', (e)=>{ if((e.target).classList.contains('mc-handle')) return; onCropDragStart(e, null); }, {passive:true});
  window.addEventListener('touchmove', onCropDragMove, {passive:true});
  window.addEventListener('touchend', onCropDragEnd, {passive:true});

  document.querySelectorAll('#mc-crop .mc-handle').forEach(h=>{
    h.addEventListener('mousedown', (e)=> onCropDragStart(e, h.dataset.h));
    h.addEventListener('touchstart', (e)=> onCropDragStart(e, h.dataset.h), {passive:true});
  });

  aspectSel.addEventListener('change', ()=>{
    const s = document.getElementById('mc-stage-wrap').getBoundingClientRect();
    if(aspectSel.value === 'free') return;
    const [aw,ah] = aspectSel.value.split(':').map(Number);
    const ratio = aw/ah;
    let w = s.width * 0.7, h = w / ratio;
    if(h > s.height * 0.7){ h = s.height * 0.7; w = h * ratio; }
    const left = (s.width - w)/2, top = (s.height - h)/2;
    cropEl.style.left = (left / s.width * 100) + '%';
    cropEl.style.top  = (top  / s.height* 100) + '%';
    cropEl.style.width= (w    / s.width * 100) + '%';
    cropEl.style.height=(h    / s.height* 100) + '%';
  });

  new ResizeObserver(()=>{ fitStage(); if(imgLoaded) render(); }).observe(document.getElementById('mc-stage-wrap'));

  // Expose close as well (if needed elsewhere)
  window.mc_closeCropper = mc_closeCropper;
})();
// ===== End Inline Modern Cropper =====
</script>


<style id="precision-tools-styles-collapsible">
  #precisionToolsDock.pt-collapsed {
    width: auto !important;
    height: auto !important;
    padding: 6px 10px !important;
  }
  #precisionToolsDock.pt-collapsed h3 { margin:0; font-size:14px; }
  #precisionToolsDock.pt-collapsed .row,
  #precisionToolsDock.pt-collapsed .divider,
  #precisionToolsDock.pt-collapsed .small:not(.dragger) {
    display: none !important;
  }
</style>

<script id="precision-tools-collapse">
(function(){
  const dock = document.getElementById("precisionToolsDock");
  if(!dock) return;
  const header = dock.querySelector("h3");
  const collapseBtn = document.createElement("button");
  collapseBtn.textContent = "‚óÄ";
  collapseBtn.className = "pill";
  collapseBtn.title = "Collapse/Expand Precision Tools";
  header.appendChild(collapseBtn);
  let collapsed = false;
  function setCollapsed(c){
    collapsed = c;
    if(collapsed){
      dock.classList.add("pt-collapsed");
      collapseBtn.textContent = "‚ñ∂";
    }else{
      dock.classList.remove("pt-collapsed");
      collapseBtn.textContent = "‚óÄ";
    }
  }
  collapseBtn.addEventListener("click", ()=> setCollapsed(!collapsed));
})();
</script>
</body>
</html>